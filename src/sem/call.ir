# @.arg.{f: Callable, args: List<Object>, suc: Pid}
proc py_call {
    %arg = @.arg;

    %ty = @.arg.f.type;
    %typemap = {};
    %typemap[%ty] = py_call_other;
    %typemap[@.singletons.function] = py_call_fn;
    %typemap[@.singletons.type] = py_call_class;
    jmp %typemap[%ty];
}

proc py_call_fn {
    %arg = @.arg;

    @.arg = {};
    @.arg.f = %arg.f.payload;
    @.arg.farg = %arg.args;
    @.arg.suc = %arg.suc;
    jmp call_fn;
}

proc py_call_class {
    @.frame.irlocals.arg_bkp = @.arg;

    @.arg = {};
    @.arg.f = py_type_attrlookup;
    @.arg.farg = {};
    @.arg.farg.obj = @.frame.irlocals.arg_bkp.f;
    @.arg.farg.attr = "__init__";
    @.arg.suc = py_call_class_1;
    jmp call_fn;
}

proc py_call_class_1 {
    %constr = @.ret; # the @.ret register currently stores the constructor.

    %tab = {};
    %tab[@.ret] = @.ret;
    %tab[@.singletons.none] = pop_stack;
    %opt_constr = %tab[@.ret];

    @.frame.irlocals.obj = {};
    @.frame.irlocals.obj.type = @.frame.irlocals.arg_bkp.f;
    @.frame.irlocals.obj.dict = {};

    @.arg = {};
    @.arg.f = %opt_constr;
    @.arg.farg = @.frame.irlocals.arg_bkp.args;
    @.arg.suc = py_call_class_2;
    jmp call_fn;
}

proc py_call_class_2 {
    @.ret = @.frame.irlocals.obj;
    jmp @.frame.irlocals.arg_bkp.suc;
}

proc py_call_other {
    panic "todo!";
}
