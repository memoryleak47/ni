# @ :: Root
#
# struct Root {
#   singletons :: Symbol -> any    # predefined objects, that are used internally in the runtime
#   globals :: String -> Object    # global variables (user-facing)
#   frame :: Frame                 # the callstack
# }
#
# struct Frame {
#   parent :: Frame | Undef
#   arg :: any                     # function args
#   retval :: Cell                 # write return value to retval.v
#   retpid :: ProcId | Undef       # when returning, jump back to this
#   pylocals :: String -> Object   # pythons local variables
#   irlocals :: Symbol -> any      # local variables for the IR
# }
#
# struct Object {
#   type :: Object                 # type(obj)
#   dict :: any                    # the dict underlying __dict__
#   ...                            # case-specific addons
# }
#
# struct Cell {
#   v :: any
# }
#
# struct FunctionObject : Object {
#   type = @.singletons.function
#   pid :: ProcId
# }

main proc init {
    # setup singletons
    @.singletons = {};
    @.singletons.function = {}; # the <function> type.
    @.singletons.none = {};     # the unique `None` value.

    # setup globals
    @.globals = {};

    # setup print
    %print_fn = {};
    %print_fn.type = @.singletons.function;
    %print_fn.pid = print_fn;
    @.globals["print"] = %print_fn;

    # setup callstack
    %frame = {};
    %frame.parent = undef;
    %frame.arg = {};
    %frame.retval = {};
    %frame.retpid = fin;
    %frame.pylocals = @.globals;
    %frame.irlocals = {};
    @.frame = %frame;

    jmp userstart;
}

proc print_fn {
    %f = @.frame;
    print %f.arg[0];
    %f.retval.v = @.singletons.none;
    @.frame = %f.parent;
    jmp %f.retpid;
}

proc fin {
    exit;
}
