proc init_list {
    @.singletons.list.type = @.singletons.type;
    @.singletons.list.dict = {};
    @.singletons.list.mro = {};
    @.singletons.list.mro[0] = @.singletons.list;
    @.singletons.list.mro[1] = @.singletons.object;

    %getitem_fn = {};
    %getitem_fn.type = @.singletons.function;
    %getitem_fn.payload = fn_list_getitem;
    @.singletons.list.dict["__getitem__"] = %getitem_fn;

    %setitem_fn = {};
    %setitem_fn.type = @.singletons.function;
    %setitem_fn.payload = fn_list_setitem;
    @.singletons.list.dict["__setitem__"] = %setitem_fn;

    %append_fn = {};
    %append_fn.type = @.singletons.function;
    %append_fn.payload = fn_list_append;
    @.singletons.list.dict["append"] = %append_fn;

    %pop_fn = {};
    %pop_fn.type = @.singletons.function;
    %pop_fn.payload = fn_list_pop;
    @.singletons.list.dict["pop"] = %pop_fn;

    %insert_fn = {};
    %insert_fn.type = @.singletons.function;
    %insert_fn.payload = fn_list_insert;
    @.singletons.list.dict["insert"] = %insert_fn;

    %init_fn = {};
    %init_fn.type = @.singletons.function;
    %init_fn.payload = fn_list_init;
    @.singletons.list.dict["__init__"] = %init_fn;

    @.globals["list"] = @.singletons.list;

    jmp init_loop;
}

proc fn_list_getitem {
    %list = @.arg[0].payload;
    %idx = @.arg[1].payload;

    @.ret = %list[%idx];

    jmp pop_stack;
}

proc fn_list_setitem {
    %list = @.arg[0].payload;
    %idx = @.arg[1].payload;
    %v = @.arg[2];

    %list[%idx] = %v;

    jmp pop_stack_none;
}

proc fn_list_append {
    %list = @.arg[0];
    %v = @.arg[1];

    %old_len = %list.length.payload;
    %intbox = {};
    %intbox.type = @.singletons.int;
    %intbox.payload = %old_len + 1;

    %list.length = %intbox;
    %list.payload[%old_len] = %v;

    jmp pop_stack_none;
}

#### POP

proc fn_list_pop {
    # TODO raise IndexError if out of bounds/empty

    %list = @.arg[0];

    # buffer containing "length-1"
    %l1 = {};
    %l1.payload = %list.length.payload - 1;

    %t = {};
    %t[@.arg[1]] = @.arg[1]; # we want to remove the index specified as argument
    %t[Undef] = %l1;         # or length-1 if no argument is given.

    # %i is the index we want to remove.
    %i = %t[@.arg[1]].payload;

    %intbox = {};
    %intbox.type = @.singletons.int;
    %intbox.payload = %list.length.payload - 1;
    %list.length = %intbox;

    @.frame.irlocals.i = %i;
    @.frame.irlocals.l = %list.payload;
    @.ret = %list.payload[%i];

    jmp fn_list_pop_2;
}

proc fn_list_pop_2 {
    %v = @.frame.irlocals.l[@.frame.irlocals.i];
    @.frame.irlocals.l[@.frame.irlocals.i] = @.frame.irlocals.l[@.frame.irlocals.i+1];
    %new_v = @.frame.irlocals.l[@.frame.irlocals.i];
    @.frame.irlocals.i = @.frame.irlocals.i + 1;

    %t = {};
    %t[%new_v] = fn_list_pop_2;
    %t[Undef] = pop_stack; # if new_v is empty
    jmp %t[%new_v];
}

#### INSERT

proc fn_list_insert {
    # TODO raise IndexError if out of bounds (probably?)

    %list = @.arg[0];
    %i = @.arg[1].payload;
    %v = @.arg[2];

    %intbox = {};
    %intbox.type = @.singletons.int;
    %intbox.payload = %list.length.payload + 1;
    %list.length = %intbox;

    @.frame.irlocals.i = %i + 1;
    @.frame.irlocals.l = %list.payload;
    @.frame.irlocals.v = %list.payload[%i];
    %list.payload[%i] = %v;

    jmp fn_list_insert_2;
}

proc fn_list_insert_2 {
    %tab = {};
    %tab[@.frame.irlocals.v] = fn_list_insert_3;
    %tab[Undef] = pop_stack_none;
    jmp %tab[@.frame.irlocals.v];
}

proc fn_list_insert_3 {
    %v = @.frame.irlocals.l[@.frame.irlocals.i];
    @.frame.irlocals.l[@.frame.irlocals.i] = @.frame.irlocals.v;
    @.frame.irlocals.i = @.frame.irlocals.i + 1;
    @.frame.irlocals.v = %v;
    jmp fn_list_insert_2;
}

#### Constructor ####

proc fn_list_init {
    %self = @.arg[0];
    %self.payload = {};

    %self.length = {};
    %self.length.payload = 0;
    %self.length.type = @.singletons.int;

    %iterable = @.arg[1];

    %tab = {};
    %tab[%iterable] = fn_list_init_args;
    %tab[Undef] = pop_stack_none;

    jmp %tab[%iterable];
}

proc fn_list_init_args {
    %h_parent = @.handler;
    @.handler = {};
    @.handler.parent = %h_parent;
    @.handler.pid = pop_stack_none;
    @.handler.frame = @.frame;

    @.frame.irlocals.self = @.arg[0];
    @.frame.irlocals.iterable = @.arg[1];

    @.arg = {};
    @.arg.obj = @.frame.irlocals.iterable;
    @.arg.attr = "__iter__";
    @.arg.suc = fn_list_init_args2;

    jmp py_attrlookup;
}

proc fn_list_init_args2 {
    @.arg = {};
    @.arg.f = @.ret;
    @.arg.suc = fn_list_init_args3;
    @.arg.args = {};

    jmp py_call;
}

proc fn_list_init_args3 {
    @.arg = {};
    @.arg.obj = @.ret;
    @.arg.attr = "__next__";
    @.arg.suc = fn_list_init_args4;

    jmp py_attrlookup;
}

proc fn_list_init_args4 {
    @.frame.irlocals.next = @.ret;
    jmp fn_list_init_1;
}

# Call "__next__" on the iterable and go to fn_list_init_2.
proc fn_list_init_1 {
    @.arg = {};
    @.arg.f = @.frame.irlocals.next;
    @.arg.suc = fn_list_init_2;
    @.arg.args = {};

    jmp py_call;
}

# Put the output of "__next__" into the list, and repeat
proc fn_list_init_2 {
    %i = @.frame.irlocals.self.length.payload;
    @.frame.irlocals.self.payload[%i] = @.ret;
    @.frame.irlocals.self.length.payload = %i + 1;
    jmp fn_list_init_1;
}
