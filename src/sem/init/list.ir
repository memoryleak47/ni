proc init_list {
    @.singletons.list.type = @.singletons.type;
    @.singletons.list.dict = {};
    @.singletons.list.mro = {};
    @.singletons.list.mro[0] = @.singletons.list;
    @.singletons.list.mro[1] = @.singletons.object;

    %getitem_fn = {};
    %getitem_fn.type = @.singletons.function;
    %getitem_fn.payload = fn_list_getitem;
    @.singletons.list.dict["__getitem__"] = %getitem_fn;

    %setitem_fn = {};
    %setitem_fn.type = @.singletons.function;
    %setitem_fn.payload = fn_list_setitem;
    @.singletons.list.dict["__setitem__"] = %setitem_fn;

    %append_fn = {};
    %append_fn.type = @.singletons.function;
    %append_fn.payload = fn_list_append;
    @.singletons.list.dict["append"] = %append_fn;

    %pop_fn = {};
    %pop_fn.type = @.singletons.function;
    %pop_fn.payload = fn_list_pop;
    @.singletons.list.dict["pop"] = %pop_fn;

    %insert_fn = {};
    %insert_fn.type = @.singletons.function;
    %insert_fn.payload = fn_list_insert;
    @.singletons.list.dict["insert"] = %insert_fn;

    %init_fn = {};
    %init_fn.type = @.singletons.function;
    %init_fn.payload = fn_list_init;
    @.singletons.list.dict["__init__"] = %init_fn;

    %len_fn = {};
    %len_fn.type = @.singletons.function;
    %len_fn.payload = fn_list_len;
    @.singletons.list.dict["__len__"] = %len_fn;

    @.globals["list"] = @.singletons.list;

    jmp init_loop;
}

# @.arg.{list, slice, suc}
# returns {.start=int, .step=int, .length=int }
# slices like [10:20:-1] will result in length=0
proc match_slice {
    %slice = @.arg.slice;
    %list = @.arg.list;

    %t = {};

    # step defaults to 1
    %t[%slice.step] = %slice.step;
    %t[Undef] = {};
    %t[Undef].payload = 1;
    %step = %t[%slice.step].payload;

    %r = {};
    %r[True] = 1;
    %r[False] = 0;

    %pos = %r[%step >= 0];

    # start defaults to 0 or 'len-1'
    %t[%slice.start] = %slice.start;
    %t[Undef] = {};
    %t[Undef].payload = (1-%pos) * (%list.length.payload - 1);
    %start = %t[%slice.start].payload;

    # end defaults to list.len or -1
    %t[%slice.end] = %slice.end;
    %t[Undef] = {};
    %t[Undef].payload = (%pos * %list.length.payload) - (1-%pos);
    %end = %t[%slice.end].payload;

    %out = {};
    %out.start = %start;
    %out.step = %step;

    # round up division!
    %out.length = ((%end - %start) / %step) + %r[((%end - %start) % %step) > 0];
    %out.list = %list;

    %out.length = %r[%out.length >= 0] * %out.length;

    @.ret = %out;

    jmp @.arg.suc;
}

#### GETITEM


proc fn_list_getitem {
    %list = @.arg[0].payload;
    %idx = @.arg[1];

    %t = {};
    %t[%idx.type] = do_fail;
    %t[@.singletons.int] = fn_list_getitem_int;
    %t[@.singletons.slice] = fn_list_getitem_slice;

    jmp %t[%idx.type];
}

proc fn_list_getitem_int {
    %list = @.arg[0].payload;
    %idx = @.arg[1].payload;

    @.ret = %list[%idx];

    jmp pop_stack;
}


proc fn_list_getitem_slice {
    %list = @.arg[0];
    %slice = @.arg[1];

    @.arg = {};
    @.arg.list = %list;
    @.arg.slice = %slice;
    @.arg.suc = fn_list_getitem_slice_2;

    jmp match_slice;
}

proc fn_list_getitem_slice_2 {
    @.frame.irlocals.start = @.ret.start;
    @.frame.irlocals.length = @.ret.length;
    @.frame.irlocals.step = @.ret.step;
    @.frame.irlocals.inlist = @.ret.list;

    %outlist = {};
    %outlist.type = @.singletons.list;
    %intbox = {};
    %intbox.payload = @.frame.irlocals.length;
    %intbox.type = @.singletons.int;

    %outlist.dict = {};
    %outlist.length = %intbox;
    %outlist.payload = {};
    @.frame.irlocals.outlist = %outlist;
    @.frame.irlocals.i = 0;

    @.ret = %outlist;

    jmp fn_list_getitem_slice_3;
}

proc fn_list_getitem_slice_3 {
    %t = {};
    %t[True] = fn_list_getitem_slice_4;
    %t[False] = pop_stack;
    jmp %t[@.frame.irlocals.i < @.frame.irlocals.length];
}

proc fn_list_getitem_slice_4 {
    %i = @.frame.irlocals.i;
    %ii = @.frame.irlocals.start + (%i * @.frame.irlocals.step);
    %tmp = @.frame.irlocals.inlist.payload[%ii];
    @.frame.irlocals.outlist.payload[%i] = %tmp;
    @.frame.irlocals.i = %i + 1;

    jmp fn_list_getitem_slice_3;
}

#### SETITEM

proc fn_list_setitem {
    %idx = @.arg[1];

    %t = {};
    %t[%idx.type] = do_fail;
    %t[@.singletons.int] = fn_list_setitem_int;
    %t[@.singletons.slice] = fn_list_setitem_slice;

    jmp %t[%idx.type];
}

proc fn_list_setitem_int {
    %list = @.arg[0].payload;
    %idx = @.arg[1].payload;
    %v = @.arg[2];

    %list[%idx] = %v;

    jmp pop_stack_none;
}

proc fn_list_setitem_slice {
    %list = @.arg[0];
    %slice = @.arg[1];
    @.frame.irlocals.inlist = @.arg[2];

    @.arg = {};
    @.arg.list = %list;
    @.arg.slice = %slice;
    @.arg.suc = fn_list_setitem_slice_2;

    jmp match_slice;
}

proc fn_list_setitem_slice_2 {
    @.frame.irlocals.start = @.ret.start;
    @.frame.irlocals.length = @.ret.length;
    @.frame.irlocals.step = @.ret.step;
    @.frame.irlocals.outlist = @.ret.list;

    # TODO check that 'len(inlist) == length'

    @.frame.irlocals.i = 0;

    jmp fn_list_setitem_slice_3;
}

proc fn_list_setitem_slice_3 {
    %t = {};
    %t[True] = fn_list_setitem_slice_4;
    %t[False] = pop_stack_none;
    jmp %t[@.frame.irlocals.i < @.frame.irlocals.length];
}

proc fn_list_setitem_slice_4 {
    %i = @.frame.irlocals.i;
    %ii = @.frame.irlocals.start + (%i * @.frame.irlocals.step);
    %tmp = @.frame.irlocals.inlist.payload[%i];
    @.frame.irlocals.outlist.payload[%ii] = %tmp;
    @.frame.irlocals.i = %i + 1;

    jmp fn_list_setitem_slice_3;
}

####

proc fn_list_append {
    %list = @.arg[0];
    %v = @.arg[1];

    %old_len = %list.length.payload;
    %intbox = {};
    %intbox.type = @.singletons.int;
    %intbox.payload = %old_len + 1;

    %list.length = %intbox;
    %list.payload[%old_len] = %v;

    jmp pop_stack_none;
}

#### POP

proc fn_list_pop {
    # TODO raise IndexError if out of bounds/empty

    %list = @.arg[0];

    # buffer containing "length-1"
    %l1 = {};
    %l1.payload = %list.length.payload - 1;

    %t = {};
    %t[@.arg[1]] = @.arg[1]; # we want to remove the index specified as argument
    %t[Undef] = %l1;         # or length-1 if no argument is given.

    # %i is the index we want to remove.
    %i = %t[@.arg[1]].payload;

    %intbox = {};
    %intbox.type = @.singletons.int;
    %intbox.payload = %list.length.payload - 1;
    %list.length = %intbox;

    @.frame.irlocals.i = %i;
    @.frame.irlocals.l = %list.payload;
    @.ret = %list.payload[%i];

    jmp fn_list_pop_2;
}

proc fn_list_pop_2 {
    %v = @.frame.irlocals.l[@.frame.irlocals.i];
    @.frame.irlocals.l[@.frame.irlocals.i] = @.frame.irlocals.l[@.frame.irlocals.i+1];
    %new_v = @.frame.irlocals.l[@.frame.irlocals.i];
    @.frame.irlocals.i = @.frame.irlocals.i + 1;

    %t = {};
    %t[%new_v] = fn_list_pop_2;
    %t[Undef] = pop_stack; # if new_v is empty
    jmp %t[%new_v];
}

#### INSERT

proc fn_list_insert {
    # TODO raise IndexError if out of bounds (probably?)

    %list = @.arg[0];
    %i = @.arg[1].payload;
    %v = @.arg[2];

    %intbox = {};
    %intbox.type = @.singletons.int;
    %intbox.payload = %list.length.payload + 1;
    %list.length = %intbox;

    @.frame.irlocals.i = %i + 1;
    @.frame.irlocals.l = %list.payload;
    @.frame.irlocals.v = %list.payload[%i];
    %list.payload[%i] = %v;

    jmp fn_list_insert_2;
}

proc fn_list_insert_2 {
    %tab = {};
    %tab[@.frame.irlocals.v] = fn_list_insert_3;
    %tab[Undef] = pop_stack_none;
    jmp %tab[@.frame.irlocals.v];
}

proc fn_list_insert_3 {
    %v = @.frame.irlocals.l[@.frame.irlocals.i];
    @.frame.irlocals.l[@.frame.irlocals.i] = @.frame.irlocals.v;
    @.frame.irlocals.i = @.frame.irlocals.i + 1;
    @.frame.irlocals.v = %v;
    jmp fn_list_insert_2;
}

#### Constructor ####

proc fn_list_init {
    %self = @.arg[0];
    %self.payload = {};

    %self.length = {};
    %self.length.payload = 0;
    %self.length.type = @.singletons.int;

    %iterable = @.arg[1];

    %tab = {};
    %tab[%iterable] = fn_list_init_args;
    %tab[Undef] = pop_stack_none;

    jmp %tab[%iterable];
}

proc fn_list_init_args {
    %h_parent = @.handler;
    @.handler = {};
    @.handler.parent = %h_parent;
    @.handler.pid = pop_stack_none;
    @.handler.frame = @.frame;

    @.frame.irlocals.self = @.arg[0];
    @.frame.irlocals.iterable = @.arg[1];

    @.arg = {};
    @.arg.obj = @.frame.irlocals.iterable;
    @.arg.attr = "__iter__";
    @.arg.suc = fn_list_init_args2;

    jmp py_attrlookup;
}

proc fn_list_init_args2 {
    @.arg = {};
    @.arg.f = @.ret;
    @.arg.suc = fn_list_init_args3;
    @.arg.args = {};

    jmp py_call;
}

proc fn_list_init_args3 {
    @.arg = {};
    @.arg.obj = @.ret;
    @.arg.attr = "__next__";
    @.arg.suc = fn_list_init_args4;

    jmp py_attrlookup;
}

proc fn_list_init_args4 {
    @.frame.irlocals.next = @.ret;
    jmp fn_list_init_1;
}

# Call "__next__" on the iterable and go to fn_list_init_2.
proc fn_list_init_1 {
    @.arg = {};
    @.arg.f = @.frame.irlocals.next;
    @.arg.suc = fn_list_init_2;
    @.arg.args = {};

    jmp py_call;
}

# Put the output of "__next__" into the list, and repeat
proc fn_list_init_2 {
    %i = @.frame.irlocals.self.length.payload;
    @.frame.irlocals.self.payload[%i] = @.ret;
    @.frame.irlocals.self.length.payload = %i + 1;
    jmp fn_list_init_1;
}

proc fn_list_len {
    @.ret = @.arg[0].length;
    jmp pop_stack;
}
